## Arrays and Hashmaps (Easy)

### 1. Two Sum

**Question**: Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.

**Brute Force Approach**: Iterate over the array in a nested loop, check the sum of each possible pair of numbers, and see if it matches the target.

- Time Complexity: O(n^2)
- Space Complexity: O(1)

**Optimal Approach**: Use a hashmap to keep track of each number's index. For each number `x`, check if `target - x` is in the hashmap.

- Time Complexity: O(n)
- Space Complexity: O(n)

**Java Code**:

```java
public int[] twoSum(int[] nums, int target) {
    // Create a hashmap to store numbers and their indices
    HashMap<Integer, Integer> map = new HashMap<>();

    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];

        // If the complement exists in the map, we found a pair
        if (map.containsKey(complement)) {
            return new int[] { map.get(complement), i };
        }

        // Otherwise, add the current number to the map
        map.put(nums[i], i);
    }

    // Return an empty array if no pair is found (this shouldn't happen per the problem's constraints)
    return new int[] {};
}
```

---

### 2. Single Number

**Question**: Given a non-empty array of integers `nums`, every element appears twice except for one. Find that single one.

**Brute Force Approach**: Use nested loops to check how many times each number appears. Return the number that appears only once.

- Time Complexity: O(n^2)
- Space Complexity: O(1)

**Optimal Approach**: Leverage the property of XOR. Any number XOR'd with itself results in 0. Thus, if we XOR all numbers together, the duplicates will cancel out, leaving the single number.

- Time Complexity: O(n)
- Space Complexity: O(1)

**Java Code**:

```java
public int singleNumber(int[] nums) {
    int result = 0;

    for (int num : nums) {
        result ^= num;  // XOR operation
    }

    return result;
}
```

---

### 3. Contains Duplicate

**Question**: Given an integer array `nums`, return true if any value appears at least twice in the array, and return false if every element is distinct.

**Brute Force Approach**: Use nested loops to check if any number appears more than once.

- Time Complexity: O(n^2)
- Space Complexity: O(1)

**Optimal Approach**: Use a HashSet to keep track of numbers seen so far. If a number appears again, return true.

- Time Complexity: O(n)
- Space Complexity: O(n)

**Java Code**:

```java
public boolean containsDuplicate(int[] nums) {
    Set<Integer> set = new HashSet<>();

    for (int num : nums) {
        if (set.contains(num)) {
            return true;  // Duplicate found
        }

        set.add(num);
    }

    return false;  // No duplicates found
}
```

---

### 4. Intersection of Two Arrays II

**Question**: Given two integer arrays `nums1` and `nums2`, return an array of their intersection.

**Brute Force Approach**: Use nested loops and for each element in the first array, check if it exists in the second one, and then remove it from the second array.

- Time Complexity: O(n \* m) (where n and m are the lengths of the two arrays)
- Space Complexity: O(1)

**Optimal Approach**: Use a hashmap to count occurrences of elements in the first array. Then iterate over the second array and reduce the count in the hashmap when a match is found.

- Time Complexity: O(n + m)
- Space Complexity: O(n) or O(m), depending on which array you choose to create the hashmap for.

**Java Code**:

```java
public int[] intersect(int[] nums1, int[] nums2) {
    Map<Integer, Integer> map = new HashMap<>();
    List<Integer> result = new ArrayList<>();

    for (int num : nums1) {
        map.put(num, map.getOrDefault(num, 0) + 1);
    }

    for (int num : nums2) {
        if (map.getOrDefault(num, 0) > 0) {
            result.add(num);
            map.put(num, map.get(num) - 1);
        }
    }

    // Convert the result list to an array
    int[] output = new int[result.size()];
    for (int i = 0; i < result.size(); i++) {
        output[i] = result.get(i);
    }

    return output;
}
```

---

### 5. Find the Difference

**Question**: Given two strings `s` and `t` which consist of only lowercase letters. `t` is generated by random shuffling string `s` and then adding one more letter at a random position. Return the letter that was added to `t`.

**Brute Force Approach**: Sort both strings and compare characters one by one. The extra character in the second string is the answer.

- Time Complexity: O(nlogn) (because of the sorting)
- Space Complexity: O(1)

**Optimal Approach**: Utilize the properties of XOR. If we XOR all characters of both strings together, the duplicates will cancel out, leaving the added character.

- Time Complexity: O(n)
- Space Complexity: O(1)

**Java Code**:

```java
public char findTheDifference(String s, String t) {
    char result = 0;

    // XOR all characters of s
    for (char c : s.toCharArray()) {
        result ^= c;
    }

    // XOR all characters of t
    for (char c : t.toCharArray()) {
        result ^= c;
```
